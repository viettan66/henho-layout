<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Custom Layout Livestream</title>
  <style>
    body {
      margin: 0;
      background: black;
      height: 100vh;
      display: grid;
      grid-template-rows: 80% 20%;
      grid-template-columns: 33.3% 33.3% 33.3%;
      grid-template-areas:
        "nguoi2 mc nguoi1"
        "banbe2 . banbe1";
      gap: 2px;
    }

    .video-box {
      position: relative;
      border: 2px solid white;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .name-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      text-align: center;
      padding: 3px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      font-size: 14px;
    }

    .mc     { grid-area: mc; }
    .nguoi1 { grid-area: nguoi1; }
    .nguoi2 { grid-area: nguoi2; }
    .banbe1 { grid-area: banbe1; display: flex; flex-wrap: nowrap; }
    .banbe2 { grid-area: banbe2; display: flex; flex-wrap: nowrap; }

    .friend-video {
      flex: 1;
      margin: 1px;
    }
  </style>
</head>
<body>
  <div class="video-box nguoi2" id="nguoi2"></div>
  <div class="video-box mc" id="mc"></div>
  <div class="video-box nguoi1" id="nguoi1"></div>
  <div class="banbe2" id="banbe2"></div>
  <div class="banbe1" id="banbe1"></div>

  <script src="https://cdn.livekit.io/js/livekit-client.min.js" onload="initLiveKit()"></script>
  <script>
    async function initLiveKit() {
      const { connect } = LiveKitClient;

    const qs = new URLSearchParams(window.location.search);
    const token = qs.get("token");
    const lkUrl = qs.get("url") || "wss://hen-ho-sf416dcq.livekit.cloud"; // override via ?url= if needed
    const focusPair = qs.get("pair") || ""; // optional pairToken to focus on

    const room = await connect(lkUrl, token, { autoSubscribe: true });

    // State store
    const state = new Map(); // identity -> { role, pairToken, vTrack, aTrack, name }

    // Helpers
    const parseMeta = (p) => {
      try { return p?.metadata ? JSON.parse(p.metadata) : {}; } catch { return {}; }
    };
    const roleOf = (p) => (parseMeta(p).role || "").toString().toLowerCase();
    const pairOf = (p) => (parseMeta(p).pairToken || "").toString();
    const genderOf = (p) => (parseMeta(p).gender || "").toString().toLowerCase();
    const isFemale = (p) => ["girl","female"].includes(genderOf(p)) || ["girl","female"].includes(roleOf(p));
    const isMale = (p) => ["boy","male"].includes(genderOf(p)) || ["boy","male"].includes(roleOf(p));

    // Containers
    const boxMc = document.getElementById('mc');
    const boxN1 = document.getElementById('nguoi1');
    const boxN2 = document.getElementById('nguoi2');
    const boxB1 = document.getElementById('banbe1');
    const boxB2 = document.getElementById('banbe2');
    const audioHub = document.createElement('div'); audioHub.style.display='none'; document.body.appendChild(audioHub);

    function attachTrack(track) {
      try {
        const el = track.attach();
        el.autoplay = true; el.playsInline = true;
        // IMPORTANT: do not mute here; egress needs audio
        const p = el.play?.(); if (p && p.catch) p.catch(()=>{});
        return el;
      } catch { return null; }
    }
    function clearNode(node) { while (node.firstChild) node.removeChild(node.firstChild); }
    function setTile(container, track, label) {
      clearNode(container);
      if (track) {
        const vid = attachTrack(track);
        if (vid) { vid.style.width='100%'; vid.style.height='100%'; vid.style.objectFit='cover'; container.appendChild(vid); }
      }
      if (label) {
        const lb = document.createElement('div'); lb.className='name-label'; lb.innerText = label; container.appendChild(lb);
      }
    }
    function upsertAudio(track, key) {
      if (!track) return;
      let a = document.getElementById(`aud-${key}`);
      if (!a) { a = document.createElement('audio'); a.id = `aud-${key}`; a.autoplay=true; audioHub.appendChild(a); }
      try { track.attach(a); const p=a.play?.(); if (p&&p.catch) p.catch(()=>{}); } catch {}
    }

    function pickLayout() {
      const entries = Array.from(state.values()).filter(s => !!s.vTrack);
      const mc = entries.find(s => s.role==='mc');
      // focusPair from URL if provided, else take first female's pairToken, else empty
      const pair = focusPair || (entries.find(s => s.role!=='mc' && s.isFemale)?.pairToken || '');
      const isMatchPair = (s) => !pair || s.pairToken===pair;
      const female = entries.find(s => s.isFemale && isMatchPair(s));
      const male = entries.find(s => s.isMale && isMatchPair(s));
      const friends = entries.filter(s => s!==mc && s!==female && s!==male);
      return { mc, female, male, friends };
    }

    function render() {
      const { mc, female, male, friends } = pickLayout();
      setTile(boxMc, mc?.vTrack, mc?.name || 'MC');
      setTile(boxN1, female?.vTrack, female?.name || 'Người 1');
      setTile(boxN2, male?.vTrack, male?.name || 'Người 2');
      clearNode(boxB1); clearNode(boxB2);
      friends.forEach((f, idx) => {
        const cont = document.createElement('div'); cont.className='video-box friend-video';
        const vid = attachTrack(f.vTrack); if (vid) cont.appendChild(vid);
        const lb = document.createElement('div'); lb.className='name-label'; lb.innerText=f.name||f.role||'Friend'; cont.appendChild(lb);
        (idx % 2 === 0 ? boxB1 : boxB2).appendChild(cont);
      });
      // Mix audio: prefer MC + two main participants
      upsertAudio(mc?.aTrack, 'mc');
      upsertAudio(female?.aTrack, 'n1');
      upsertAudio(male?.aTrack, 'n2');
    }

function ingestParticipant(p) {
  const meta = parseMeta(p);
  const base = {
    role: (meta.role || '').toLowerCase(),
    pairToken: (meta.pairToken || '').toString(),
    name: p.name || p.identity,
    isFemale: ["girl","female"].includes((meta.role||'').toLowerCase()),
    isMale: ["boy","male"].includes((meta.role||'').toLowerCase())
  };
  function mergeEntry(id, patch) {
  const prev = state.get(id) || {};
  const next = { ...prev, ...patch };
  state.set(id, next);
  return next;
}

  // merge info (giữ nguyên track nếu có)
  const entry = mergeEntry(p.identity, base);

  // nếu đã có track publish sẵn thì thêm vào entry
  p.tracks?.forEach?.(pub => {
    const t = pub?.track;
    if (!t) return;
    if (t.kind === 'video') entry.vTrack = t;
    if (t.kind === 'audio') entry.aTrack = t;
  });

  state.set(p.identity, entry);
  render();
}

    // Seed
    room.participants.forEach(ingestParticipant);
    ingestParticipant(room.localParticipant);

    // Events
    room.on('participantConnected', ingestParticipant);
    room.on('participantDisconnected', (p)=>{ state.delete(p.identity); render(); });
    room.on('participantMetadataChanged', (p)=>{ ingestParticipant(p); });
    room.on('trackSubscribed', (track, pub, p) => {
  const patch = {};
  if (track.kind === 'video') patch.vTrack = track;
  if (track.kind === 'audio') patch.aTrack = track;
  mergeEntry(p.identity, patch);
  render();
});
    room.on('trackUnsubscribed', (track, pub, p) => {
      const e = state.get(p.identity) || {}; if (track.kind==='video') e.vTrack = undefined; else if (track.kind==='audio') e.aTrack=undefined; state.set(p.identity, e); render();
    });
    }
  </script>
</body>
</html>
