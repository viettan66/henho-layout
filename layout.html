<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Custom Layout Livestream</title>
  <style>
    body {
      margin: 0; 
      background: black;
      height: 100vh;
      display: grid;
      grid-template-rows: 80% 20%;
      grid-template-columns: 33.3% 33.3% 33.3%;
      grid-template-areas:
        "nguoi2 mc nguoi1"
        "banbe2 . banbe1";
      gap: 2px;   
    }

    .video-box {
      position: relative;
      border: 2px solid white;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .name-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      text-align: center;
      padding: 3px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      font-size: 14px;
    }

    .mc     { grid-area: mc; }
    .nguoi1 { grid-area: nguoi1; }
    .nguoi2 { grid-area: nguoi2; }
    .banbe1 { grid-area: banbe1; display: flex; flex-wrap: nowrap; }
    .banbe2 { grid-area: banbe2; display: flex; flex-wrap: nowrap; }

    .friend-video {
      flex: 1;
      margin: 1px;
    }
  </style>
</head>
<body>
  <div class="video-box nguoi2" id="nguoi2"></div>
  <div class="video-box mc" id="mc"></div>
  <div class="video-box nguoi1" id="nguoi1"></div>
  <div class="banbe2" id="banbe2"></div>
  <div class="banbe1" id="banbe1"></div>

  <script>
    async function initLiveKit() {
      try {
        const livekitNS = window.LivekitClient || window.LiveKitClient || window.LiveKit || window.livekit;
        if (!livekitNS) {
          console.error('LiveKit namespace not found');
          return;
        }

      function resolveConnect(ns) {
        const candidates = [
          { fn: ns?.connect, ctx: ns },
          { fn: ns?.default?.connect, ctx: ns?.default },
          { fn: ns?.Room?.connect, ctx: ns?.Room },
          { fn: ns?.default?.Room?.connect, ctx: ns?.default?.Room },
          { fn: ns?.LivekitClient?.connect, ctx: ns?.LivekitClient },
          { fn: ns?.default?.LivekitClient?.connect, ctx: ns?.default?.LivekitClient },
          { fn: typeof ns === 'function' ? ns : undefined, ctx: ns },
        ];
        for (const candidate of candidates) {
          if (typeof candidate.fn === 'function') {
            return candidate.fn.bind(candidate.ctx);
          }
        }
        if (typeof ns?.Room === 'function') {
          return async (url, token, opts) => {
            const room = new ns.Room();
            await room.connect(url, token, opts);
            return room;
          };
        }
        if (typeof ns?.default?.Room === 'function') {
          return async (url, token, opts) => {
            const room = new ns.default.Room();
            await room.connect(url, token, opts);
            return room;
          };
        }
        return null;
      }

      const connectFn = resolveConnect(livekitNS);
      if (!connectFn) {
        const nsDetails = typeof livekitNS === 'object' ? Object.keys(livekitNS) : typeof livekitNS;
        console.error('LiveKit connect function unavailable', { namespace: nsDetails });
        return;
      }

    const qs = new URLSearchParams(window.location.search);
    let token = qs.get("token");
    
    // Nếu không có token trong query, thử đọc từ hash
    if (!token && window.location.hash) {
      // Hash có dạng #token=abc123, cần parse đúng cách
      const hashString = window.location.hash.substring(1); // bỏ dấu #
      if (hashString.startsWith('token=')) {
        token = decodeURIComponent(hashString.substring(6)); // bỏ "token="
      } else {
        // Fallback: thử parse như query string
        const hashParams = new URLSearchParams(hashString);
        token = hashParams.get("token");
      }
    }
    
    const lkUrl = qs.get("url") || "wss://hen-ho-sf416dcq.livekit.cloud"; // override via ?url= if needed
    const focusPair = qs.get("pair") || ""; // optional pairToken to focus on

    console.log('Layout params:', { 
      lkUrl, 
      hasToken: !!token,
      tokenLength: token?.length || 0,
      tokenPreview: token ? token.slice(0, 50) + '...' : 'null',
      fullUrl: window.location.href
    });
    
    if (!token) {
      console.error('No token found in URL params or hash');
      return;
    }

    const room = await connectFn(lkUrl, token, { autoSubscribe: true });
    console.log('Connected to room successfully');

    // State store
    const state = new Map(); // identity -> { role, pairToken, vTrack, aTrack, name }

    function mergeEntry(id, patch) {
      const prev = state.get(id) || {};
      const next = { ...prev, ...patch };
      state.set(id, next);
      return next;
    }

    // Helpers
    const parseMeta = (p) => {
      try { return p?.metadata ? JSON.parse(p.metadata) : {}; } catch { return {}; }
    };
    const roleOf = (p) => (parseMeta(p).role || "").toString().toLowerCase();
    const pairOf = (p) => (parseMeta(p).pairToken || "").toString();
    const genderOf = (p) => (parseMeta(p).gender || "").toString().toLowerCase();
    const isFemale = (p) => ["girl","female"].includes(genderOf(p)) || ["girl","female"].includes(roleOf(p));
    const isMale = (p) => ["boy","male"].includes(genderOf(p)) || ["boy","male"].includes(roleOf(p));

    // Containers
    const boxMc = document.getElementById('mc');
    const boxN1 = document.getElementById('nguoi1');
    const boxN2 = document.getElementById('nguoi2');
    const boxB1 = document.getElementById('banbe1');
    const boxB2 = document.getElementById('banbe2');
    const audioHub = document.createElement('div'); audioHub.style.display='none'; document.body.appendChild(audioHub);

    function attachTrack(track) {
      try {
        const el = track.attach();
        el.autoplay = true; el.playsInline = true;
        // IMPORTANT: do not mute here; egress needs audio
        const p = el.play?.(); if (p && p.catch) p.catch(()=>{});
        return el;
      } catch { return null; }
    }
    function clearNode(node) { while (node.firstChild) node.removeChild(node.firstChild); }
    function setTile(container, track, label) {
      clearNode(container);
      if (track) {
        const vid = attachTrack(track);
        if (vid) { vid.style.width='100%'; vid.style.height='100%'; vid.style.objectFit='cover'; container.appendChild(vid); }
      }
      if (label) {
        const lb = document.createElement('div'); lb.className='name-label'; lb.innerText = label; container.appendChild(lb);
      }
    }
    function upsertAudio(track, key) {
      if (!track) return;
      let a = document.getElementById(`aud-${key}`);
      if (!a) { a = document.createElement('audio'); a.id = `aud-${key}`; a.autoplay=true; audioHub.appendChild(a); }
      try { track.attach(a); const p=a.play?.(); if (p&&p.catch) p.catch(()=>{}); } catch {}
    }

    function pickLayout() {
      const entries = Array.from(state.values()).filter(s => !!s.vTrack);
      const mc = entries.find(s => s.role==='mc');
      // focusPair from URL if provided, else take first female's pairToken, else empty
      const pair = focusPair || (entries.find(s => s.role!=='mc' && s.isFemale)?.pairToken || '');
      const isMatchPair = (s) => !pair || s.pairToken===pair;
      const female = entries.find(s => s.isFemale && isMatchPair(s));
      const male = entries.find(s => s.isMale && isMatchPair(s));
      const friends = entries.filter(s => s!==mc && s!==female && s!==male);
      return { mc, female, male, friends };
    }

    function render() {
      const { mc, female, male, friends } = pickLayout();
      console.log('Rendering layout:', { 
        mc: mc?.name || 'none', 
        female: female?.name || 'none', 
        male: male?.name || 'none', 
        friends: friends.length 
      });
      
      setTile(boxMc, mc?.vTrack, mc?.name || 'MC');
      setTile(boxN1, female?.vTrack, female?.name || 'Người 1');
      setTile(boxN2, male?.vTrack, male?.name || 'Người 2');
      clearNode(boxB1); clearNode(boxB2);
      friends.forEach((f, idx) => {
        const cont = document.createElement('div'); cont.className='video-box friend-video';
        const vid = attachTrack(f.vTrack); if (vid) cont.appendChild(vid);
        const lb = document.createElement('div'); lb.className='name-label'; lb.innerText=f.name||f.role||'Friend'; cont.appendChild(lb);
        (idx % 2 === 0 ? boxB1 : boxB2).appendChild(cont);
      });
      // Mix audio: prefer MC + two main participants
      upsertAudio(mc?.aTrack, 'mc');
      upsertAudio(female?.aTrack, 'n1');
      upsertAudio(male?.aTrack, 'n2');
    }

function ingestParticipant(p) {
  console.log('Ingesting participant:', { 
    identity: p.identity, 
    name: p.name, 
    metadata: p.metadata,
    tracks: p.tracks?.size || 0
  });
  
  const meta = parseMeta(p);
  const role = (meta.role || '').toLowerCase();
  const pairToken = (meta.pairToken || '').toString();
  const isFemaleRole = ["girl","female"].includes(role);
  const isMaleRole = ["boy","male"].includes(role);

  const entry = mergeEntry(p.identity, {
    role,
    pairToken,
    name: p.name || p.identity,
    isFemale: isFemaleRole,
    isMale: isMaleRole
  });

  p.tracks?.forEach?.(pub => {
    const t = pub?.track;
    if (!t) return;
    console.log(`Track ${t.kind} for ${p.identity}:`, { subscribed: pub.isSubscribed });
    if (t.kind === 'video') entry.vTrack = t;
    if (t.kind === 'audio') entry.aTrack = t;
  });

  render();
}

    // Seed existing participants (LiveKit v2 exports remoteParticipants map)
    const remoteMap = room.participants || room.remoteParticipants || new Map();
    if (typeof remoteMap.forEach === 'function') {
      remoteMap.forEach((participant) => {
        if (participant) ingestParticipant(participant);
      });
    }
    if (room.localParticipant) {
      ingestParticipant(room.localParticipant);
    }

    // Events
    room.on('participantConnected', (p) => {
      console.log('Participant connected:', p.identity);
      ingestParticipant(p);
    });
    room.on('participantDisconnected', (p) => {
      console.log('Participant disconnected:', p.identity);
      state.delete(p.identity); 
      render(); 
    });
    room.on('participantMetadataChanged', (...args) => {
      const participant = args[1] && typeof args[1] === 'object' ? args[1] : args[0];
      if (participant && participant.identity) {
        console.log('Participant metadata changed:', participant.identity);
        ingestParticipant(participant);
      }
    });
    room.on('trackSubscribed', (track, pub, p) => {
      console.log(`Track subscribed: ${track.kind} from ${p.identity}`);
      const patch = {};
      if (track.kind === 'video') patch.vTrack = track;
      if (track.kind === 'audio') patch.aTrack = track;
      mergeEntry(p.identity, patch);
      render();
    });
    room.on('trackUnsubscribed', (track, pub, p) => {
      console.log(`Track unsubscribed: ${track.kind} from ${p.identity}`);
      const patch = {};
      if (track.kind === 'video') patch.vTrack = undefined;
      if (track.kind === 'audio') patch.aTrack = undefined;
      mergeEntry(p.identity, patch);
      render();
    });
    
    room.on('disconnected', (reason) => {
      console.log('Room disconnected:', reason);
    });
    
    room.on('reconnecting', () => {
      console.log('Room reconnecting...');
    });
    
    room.on('reconnected', () => {
      console.log('Room reconnected');
    });
    
    } catch (error) {
      console.error('Error initializing LiveKit:', error);
    }
    }

    // Load LiveKit and initialize when ready
    const script = document.createElement('script');
    script.src = 'https://unpkg.com/livekit-client@2.5.3/dist/livekit-client.umd.js';
    script.onload = function() {
      setTimeout(initLiveKit, 100);
    };
    script.onerror = function() {
      console.error('Failed to load LiveKit script');
    };
    document.head.appendChild(script);
  </script>
</body>
</html>
